<!doctype html>
<!-- 中文: 简单的聊天前端（支持流式显示与心跳）。在开发模式下通过 9101 端口访问。 -->
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <title>OQS_step2 • Chat</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --bg:#0b1020; --panel:#121935; --muted:#8aa0c6; --fg:#e6f0ff; --brand:#6ea8ff; --chip:#1b2650; --danger:#ff6b6b; }
    * { box-sizing: border-box }
    html, body { height: 100%; margin: 0; }
    body { background: linear-gradient(180deg, var(--bg), #0f1630); color: var(--fg); font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    .wrap { max-width: 980px; margin: 0 auto; display: grid; grid-template-rows: auto 1fr auto; height: 100%; padding: 16px; gap: 12px; }
    header { display: flex; align-items: center; gap: 12px; }
    header h1 { font-size: 18px; margin: 0; font-weight: 600; letter-spacing: .3px; }
    header .pill { background: var(--chip); border: 1px solid #2a386d; color: var(--muted); padding: 4px 8px; border-radius: 999px; font-size: 12px; }
    header .right { margin-left: auto; display: flex; gap: 8px; align-items: center; }
    a.mini { color: var(--muted); text-decoration: none; font-size: 12px; border: 1px solid #223063; padding: 6px 8px; border-radius: 8px; }
    a.mini:hover { border-color: #2e4283; color: #a8b7dc; }
    .panel { background: rgba(255,255,255,.02); border: 1px solid #1b2750; border-radius: 14px; }
    #chat { padding: 12px; display: grid; gap: 10px; overflow: auto; }
    .bubble { max-width: 82%; padding: 10px 12px; border-radius: 12px; line-height: 1.35; white-space: pre-wrap; }
    .u { justify-self: end; background: #23418f; border: 1px solid #3b5fcc; }
    .a { justify-self: start; background: #121a38; border: 1px solid #223063; }
    .meta { color: var(--muted); font-size: 12px; margin-top: 6px; }
    .row { display: grid; grid-template-columns: 1fr auto; gap: 8px; padding: 10px; }
    .row input, .row textarea { width: 100%; background: #0f1836; color: var(--fg); border: 1px solid #243364; border-radius: 12px; padding: 12px 12px; outline: none; }
    .row textarea { resize: vertical; min-height: 48px; max-height: 40vh; }
    .btn { background: var(--brand); color: #0b1020; border: none; border-radius: 12px; padding: 0 16px; font-weight: 600; cursor: pointer; }
    .btn[disabled] { opacity: .6; cursor: not-allowed; }
    .toolbar { display: flex; gap: 8px; align-items: center; padding: 6px 10px 12px; color: var(--muted); font-size: 12px; }
    .toolbar select, .toolbar input { background: #0f1836; color: var(--fg); border: 1px solid #243364; border-radius: 10px; padding: 6px 8px; }
    .dot-pulse { display:inline-flex; gap:4px; margin-left:6px; vertical-align: middle; }
    .dot-pulse i { width:6px; height:6px; background:#9ec0ff; border-radius:50%; opacity:.4; animation: pulse 1s infinite; }
    .dot-pulse i:nth-child(2){ animation-delay:.15s } .dot-pulse i:nth-child(3){ animation-delay:.3s }
    @keyframes pulse { 0%{opacity:.2; transform: translateY(0)} 50%{opacity:1; transform: translateY(-3px)} 100%{opacity:.2; transform: translateY(0)} }
    footer { display: flex; justify-content: space-between; color: var(--muted); font-size: 12px; padding: 4px 2px 8px; }
    .err { color: var(--danger); }
    @media (max-width: 720px) { .bubble { max-width: 95% } .toolbar { flex-wrap: wrap } }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>OQS_step2 • Chat</h1>
      <span class="pill" id="pillModel">modelo…</span>
      <span class="pill" id="pillCfg">ctx/predict…</span>
      <div class="right">
        <a class="mini" href="/config" target="_blank">/config</a>
        <a class="mini" href="/health" target="_blank">/health</a>
        <a class="mini" href="/models" target="_blank">/models</a>
      </div>
    </header>

    <main class="panel">
      <div id="chat" aria-live="polite"></div>
      <div class="toolbar">
        <label><input type="checkbox" id="stream" checked /> streaming</label>
        <label>modelo:
          <select id="model">
            <option>llama3.2:3b</option>
            <option>llama3.2:1b</option>
          </select>
        </label>
        <label>num_predict:
          <input id="num_predict" type="number" value="64" min="16" max="2048" step="16" style="width:92px" />
        </label>
        <span id="lat" class="meta">latência: —</span>
        <span id="hb" class="meta">hb: —</span>
        <button class="mini" id="btnClear" type="button" style="margin-left:auto">limpar</button>
      </div>
      <div class="row">
        <textarea id="msg" placeholder="Digite sua mensagem… (Enter para enviar, Shift+Enter para quebra de linha)"></textarea>
        <button id="send" class="btn">Enviar</button>
      </div>
    </main>

    <footer>
      <div>Conectado a <span class="meta">http://localhost:9101</span></div>
      <div class="meta">Dica: no streaming ignoro linhas que começam com <code>:</code> (<code>:preamble</code>, <code>:hb</code>)</div>
    </footer>
  </div>

<script>
const $ = (q) => document.querySelector(q);
const chatEl = $("#chat");
const msgEl = $("#msg");
const modelEl = $("#model");
const sendBtn = $("#send");
const streamEl = $("#stream");
const numPredEl = $("#num_predict");
const latEl = $("#lat");
const hbEl = $("#hb");
const pillModel = $("#pillModel");
const pillCfg = $("#pillCfg");
const dec = new TextDecoder();

let lastHB = "—";
let busy = false;

function scrollToBottom(){ chatEl.scrollTop = chatEl.scrollHeight; }

function bubble(text, who="a"){
  const b = document.createElement("div");
  b.className = `bubble ${who}`;
  b.textContent = text || "";
  chatEl.appendChild(b);
  scrollToBottom();
  return b;
}

function meta(text){
  const m = document.createElement("div");
  m.className = "meta";
  m.textContent = text;
  chatEl.appendChild(m);
  scrollToBottom();
  return m;
}

function typingBubble(){
  const b = bubble("", "a");
  b.innerHTML = 'digitando<span class="dot-pulse"><i></i><i></i><i></i></span>';
  return b;
}

async function loadConfig(){
  try{
    const r = await fetch("/config");
    const cfg = await r.json();
    pillModel.textContent = cfg.model || "—";
    pillCfg.textContent = `ctx ${cfg.num_ctx ?? "?"} • pred ${cfg.num_predict ?? "?"}`;
    if (cfg.model) modelEl.value = cfg.model;
    if (typeof cfg.num_predict === "number") numPredEl.value = cfg.num_predict;
  }catch{}
}
loadConfig();

function hbTick(){
  hbEl.textContent = `hb: ${lastHB}`;
}
setInterval(hbTick, 500);

async function send(){
  if (busy) return;
  const text = (msgEl.value || "").trim();
  if (!text) return;

  busy = true;
  sendBtn.disabled = true;

  // render usuário
  bubble(text, "u");
  const aBubble = bubble("", "a"); // onde vamos pintar a resposta
  const t0 = performance.now();
  lastHB = "—";

  const model = modelEl.value;
  const num_predict = parseInt(numPredEl.value || "128", 10) || 128;

  try{
    const url = `/chat?model=${encodeURIComponent(model)}&num_predict=${num_predict}`;
    const body = JSON.stringify({ message: text, stream: !!streamEl.checked });

    if (streamEl.checked){
      const r = await fetch(url, { method: "POST", headers:{ "Content-Type":"application/json" }, body });
      if (!r.ok) throw new Error(`HTTP ${r.status}`);
      if (!r.body) throw new Error("Sem corpo legível (ReadableStream)");

      const reader = r.body.getReader();
      let buf = "";
      let firstToken = true;
      while(true){
        const {value, done} = await reader.read();
        if (done) break;
        const chunk = dec.decode(value);
        buf += chunk;

        // consome por linhas para filtrar heartbeats e preamble
        let idx;
        while((idx = buf.indexOf("\n")) >= 0){
          const line = buf.slice(0, idx);
          buf = buf.slice(idx + 1);
          if (line.startsWith(":")){
            // :preamble ou :hb
            if (line.startsWith(":hb")) lastHB = new Date().toLocaleTimeString();
            continue;
          }
          if (line.length){
            if (firstToken) { aBubble.textContent = ""; firstToken = false; }
            aBubble.textContent += line;
            scrollToBottom();
          }
        }
        // o que sobrar sem \n fica no buffer
      }
      if (buf && !buf.startsWith(":")){
        if (firstToken) aBubble.textContent = "";
        aBubble.textContent += buf;
      }
    } else {
      const r = await fetch(url, { method: "POST", headers:{ "Content-Type":"application/json" }, body });
      const data = await r.json();
      aBubble.textContent = data.reply || "(sem resposta)";
    }

    const dt = Math.max(1, Math.round(performance.now() - t0));
    latEl.textContent = `latência: ${dt} ms`;
  }catch(e){
    aBubble.innerHTML = `<span class="err">[erro]</span> ${e}`;
  }finally{
    busy = false;
    sendBtn.disabled = false;
    msgEl.value = "";
    msgEl.focus();
    scrollToBottom();
  }
}

sendBtn.addEventListener("click", send);
msgEl.addEventListener("keydown", (ev)=>{
  if (ev.key === "Enter" && !ev.shiftKey){
    ev.preventDefault();
    send();
  }
});

$("#btnClear").addEventListener("click", ()=>{
  chatEl.innerHTML = "";
});

</script>
</body>
</html>
